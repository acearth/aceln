itergral division in py3:
	3//2 #=>1
	3/2 #=1.5

reload(<<module>>)  reload modules again to make module run again.

use namespace to minimize naming collision, occurred as a object has attributes. Every module file is a namespace.

object ::a set of data and operation on it(data)
弱类型： 可以将一块内存内容视为不同的类型，如C/C++
强类型：Python,如果一块内存为字符串，那么无法对其求和（字符串无法与数字求和）
slice操作： string[#head:#tail]
分片表达式赋值前会创建拷贝
赋值操作总是存储对象的引用，而非对象的拷贝

You can't change  string contents(i.e. str[i]='char'), but you can (str='char'+str_new)

dictionary :: D={'key':'value',:::}
tuple:: T=(1,2,3,4,,,)
list:: L=[1,2,'asdf',,,]
'//' ::floor division, 解决除法结果取决于操作内型而产生不同结果的问题，避免使python作为动态语言变得难以预料

'/':: true division
0b[1][0][...] 二进制数字
变量名实质上是指向对象内存空间的指针
例子1
a=3
b=a
那么a=3,b=3
然后例子1.1
a='stringa'
那么a='stringa',b=3
由于整数/字符串是不可改变类型，赋值时实际创建了新对象

x==y 是否有相同的值
x is y 是否同一个对象,只比较实现引用的指针


零字符不会中断字符串
使用字符串需要注意转义，'c:\new\text.txt'中\n,\t都会被转义，可以使用r'c:\new\text.txt'来转义,或者使用\\

三重字符串""" ......"""，在换行处嵌入了\n。 可用作多行注释

try except else 
	首先使用try测试是否条件，如果有异常就执行except，否则没有异常，就执行else语句。

range(#N) #=> 0,1,2,...,N-1，一般用于循环

python对象无法在原处改变，故无自增自减运算

重定向输出流
import sys
sys.stdout=open('name.txt','a')
print xxx
sys.stdout.close()

使用 print>> 到对象
log=open('name.txt','w')
print >> log, CONTENT
log.close()

使用print string, 以保证输出在同一行上。

all(a,b,c) ａｂｃ全ｔｒｕｅ则ｔｒｕｅ 
any(a,b,c) ａｂｃ有一个ｔｒｕｅ则ｔｒｕｅ 


zip(la,lb)　用于将la lb联合起来并行遍历，可以用于制作字典。
对列表解析的解释不够详细

dict(zip(li1,li2))　将列表对象返回字典
无返回值的函数自动返回none对象

python不能区分同名函数与变量，如open

global x=3;　在函数中将ｘ定义为全局变量


对于多层嵌套的工厂函数，使用时要从外部传入参数，一层层传入.如
def m1(n1):
	def m2(n2):
		def m3(n3):
			return n3*n2*n1
		return m3
	return m2
可以使用p=m1(3),q=p(5), q(11)调用m3.

return x,y #->这里实际返回了(x,y)，但是括号被省略了。
关键字参数：通过变量名匹配参数，而不是通过位置顺序（默认为此）

def func(**args)   At there, only dict.key.param is valid

一个函数副作用的例子
list=[1,2,3]
list=list.append(4)
print list #=>None
cf. CHAPTER14 常见函数的陷阱
 
NNQ:=>notion of name qualification::其实是表达式，传回和对象匹配的属性名的值

reload会影响所有使用import读取了模块的客户端。因为使用import的客户端需要通过NNQ。重载后会发现模块对象中有了新值。

对用使用from的客户端，只会影响之后的对象，之前的不会影响。
from比import多的行为： 从被导入模块中复制一或多个变量到from语句所在的作用域中。这样，才可以直接使用被导入的变量名，而不是module.name。

from的问题：
	1)变量含义模糊，难以确定是那个模块定义的;
	2)reload调用时不能更新；
	3）破坏命名空间，可能会悄然覆盖正在作用域的变量名
form * 更会严重污染命名空间，宜少用。

重载::在对象树(类树）的
